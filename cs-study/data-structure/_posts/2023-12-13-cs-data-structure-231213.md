---
layout: post
title: "Data Structure"
date: 2023-12-13 13:42:20 +0900
description: 'CS: 자료구조'
img: # Add image post (optional)
fig-caption: # Add figcaption (optional)
tags: [ArrayList, LinkedList, 자료구조, 스택, queue, tree, heap]
categories: [cs-study, data-structure]
---
# Stack, Queue, Tree, Heap

- 각각의 특성에 따라 다양한 응용 분야에서 사용되며, 프로그램 및 알고리즘 설계에서 효율적인 데이터 구조의 선택이 중요함

## 1. 스택(Stack)

- 스택은 데이터를 쌓아 올린 형태
- 마지막에 추가된 항목이 가장 먼저 제거되는 후입선출(LIFO, Last-In-First-Out) 구조
- 주로 함수 호출이나 재귀 알고리즘, 실행 취소/다시 실행 등에 사용

## 2. 큐(Queue)

- 큐는 데이터를 일렬로 늘어놓은 형태
- 처음에 추가된 항목이 가장 먼저 제거되는 선입선출(FIFO, First-In-First-Out) 구조
- 주로 작업 대기열, 탐색 알고리즘, 버퍼 등에서 사용

## 3. 트리(Tree)

- 트리는 계층적인 구조를 갖춘 자료 구조
- 부모와 자식 노드들로 이루어져 있음
- 각 노드는 하나의 부모와 여러 개의 자식을 가질 수 있음
- 트리는 이진 트리, 이진 탐색 트리, AVL 트리, 힙 등 다양한 형태로 확장 가능
- 데이터의 삽입, 삭제, 검색이 효율적으로 이루어짐

  → 데이터베이스, 파일 시스템, 네트워크 라우팅 등에 사용


## 4. 힙(Heap)

- 힙은 특정한 규칙을 따르는 트리 자료 구조 중 하나
- 부모 노드와 자식 노드 간의 정렬 규칙이 정해져 있음
- 힙은 최대 힙과 최소 힙으로 나뉨
- 최대 힙은 각 노드가 자식보다 크거나 같은 값을 갖는 특성을 가지며, 최소 힙은 각 노드가 자식보다 작거나 같은 값을 가짐
- 주로 우선순위 큐와 같은 자료 구조를 구현하는 데 사용

---

# Array, LinkedList의 정의와 각각의 사용 방법

- 데이터를 저장하고 관리하는 데 사용되는 기본적인 자료구조

## Array (배열)

- 미리 할당된 크기에 연관된 데이터를 메모리 상에 연속적이고 순차적으로 저장하는 선형 자료구조
- 고정된 크기 가짐
  - 배열은 생성할 때 크기 지정
  - 크기 고정되어있어 동적으로 조절하기 어려움
- 인덱스 기반 접근
  - 각 요소 인덱스 사용하여 직접 접근 가능
  - 특정 위치에 있는 요소를 찾을 수 있음
- 메모리 공간의 연속적 할당
  - 배열의 요소들은 메모리에 연속적으로 할당

### 사용 방법

- 데이터 순차적 저장
  - 데이터 순차적으로 저장함
  - 순차적으로 접근하는 작업이 자주 필요한 경우 적합
- 고정된 크기의 데이터 집합
  - 크기가 고정되어있는 경우 사용 시 효율적
- Random Access
  - 특정 인덱스로 빠르게 액세스해야하는 경우 유용

## LinkedList (연결 리스트)

- 노드라는 구조체에 데이터 값과 다음 노드의 주소를 저장하고 있는 자료구조
- 기존 배열의 자료구조의 삽입/삭제 비효율성을 해소하기 위해 등장
- 데이터는 물리적으로 비연속적으로 저장되어 있지만 각 노드들이 다음 노드의 주소를 가리키고 있으므로 논리적으로는 연속
- 데이터가 추가되는 시점에 메모리가 할당되기 때문에 메모리를 더 효율적으로 쓸 수 있음
- 삽입/삭제 시 다음 노드의 주소만 바꿔주면 되기 때문에 데이터 이동에 시간을 들이지 않아 속도가 더 빠름
- 반면 데이터 조회 시 헤드부터 도달하고자하는 노드까지 순차적으로 접근해야하기 때문에 데이터 조회 속도는 느린 편 (랜덤 엑세스 불가능)
- Head 주소를 반드시 기억해야 . 그렇지 않으면 탐색이나 삽입/삭제를 수행할 수 없다.
- 가변 크기
  - 동적으로 크기 조절 가능
  - 요소를 추가하거나 제거할 때마다 크기 조절됨
- 포인터로 연결된 노드
  - 각 요소는 데이터와 다음 요소를 가리키는 포인터로 이루어진 노드로 구성됨
- 비 연속적 메모리 할당
  - 노드들은 메모리에 연속적으로 저장되지 않음
  - 각 노드는 독립적으로 메모리에 할당됨

### 단점

- 실 연산 속도 저하
  - 연결리스트의 데이터의 물리적인 저장 위치가 비연속적으로 분산되어있기 때문
- 주소 저장으로 인한 공간 낭비
  - 다음 노드의 주소를 저장하고 있어야 하기 때문에 배열보다 더 많은 저장공간 사용
- 복잡한 연산으로 인한 오버헤드 발생

### 사용 방법

- 동적 크기의 데이터 집합
  - 크기가 동적으로 변하는 경우 유용
- 데이터 삽입 및 삭제
  - 데이터의 삽입 또는 삭제가 빈번한 경우
- 메모리 공간이 연속적으로 사용될 수 없는 경우
  - 노드가 독립적으로 메모리에 할당되기 때문에 연속적인 메모리 공간이 필요하지 않음

## Array vs LinkedList

### 1. 메모리 구조

- Array: 데이터가 메모리에 연속적으로 저장
- Linked List: 메모리 상에서는 데이터가 연속적이지 않지만 각 노드가 다음 노드의 주소를 가지고 있으므로 논리적으로는 연속성 유지

### 2. 시간복잡도

- 메모리 구조의 차이로 시간복잡도 차이 존재

|  | Array | Linked List |
| --- | --- | --- |
| 조회 | O(1) | O(n) |
| 삽입 / 삭제 | O(n) | O(1) |
- 조회
  - 배열은 데이터에 즉시 접근 가능
  - Linked List는 순차접근만 가능
- 삽입 / 삭제
  - 배열: 마지막 위치에 데이터를 삽입 / 삭제하는 경우를 제외하면 인덱스를 조정해야 하기 때문에 데이터 shifting이 일어남
  - 연결리스트는 삽입 / 삭제 시 다음 노드의 주소 값만 바꾸면 됨

### 3. 메모리

- 메모리 낭비
  - 배열
    - 선언시 고정된 크기 할당
    - 데이터가 저장되고 있지 않더라도 공간을 차지하게 되어 메모리 낭비 발생
  - 연결리스트
    - 런타임 중 크기를 늘리거나 줄일 수 있기 때문에 필요한 만큼만 메모리를 할당하여 낭비 발생 X
- 메모리 할당 시점
  - 배열
    - 정적 메모리 할당
    - 컴파일 단계에서 메모리 할당됨
  - 연결리스트
    - 동적 메모리 할당
    - 런타임 중 노드가 추가되는 시점에서 메모리 할당
- 메모리 할당 영역
  - 배열
    - 데이터 메모리 영역
    - 로컬 변수로 선언된 경우 스택영역에 할당
  - 연결리스트
    - 힙 영역
